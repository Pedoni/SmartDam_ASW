\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage[margin=1in]{geometry}

\title{
    Smart Dam \\
    \large Applicazioni e Servizi Web
}

\author{\href{mailto:emalama@studio.unibo.it}{Emanuele Lamagna} - 000725342\\\href{mailto:filippo.barbari@studio.unibo.it}{Filippo Barbari} - 000123456\\\href{mailto:filippo.benvenuti3@studio.unibo.it}{Filippo Benvenuti} - 0001027545}
\date{\today}

\begin{document}

\maketitle
\section*{Introduzione}\label{sec:intro}
L'idea è di rivisitare un progetto svolto nell'ambito del corso di Sistemi Embedded e Internet of Things, che consisteva nella simulazione di una diga smart e monitoraggio del livello idrometrico di un fiume. il sistema era composto da 5 sottosistemi, descritti dall'immagine \ref{fig:dam-scheme}.
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.7]{dam-scheme.png}
	\caption{Diagramma dei componenti di DAM}
	\label{fig:dam-scheme}
\end{figure}
L'idea è di rifare da zero backend e frontend utilizzando Node e Vue, oltre all'utilizzo di MongoDB per il salvataggio dei dati. Inoltre per evitare di riesumare Arduino, ESP e l'applicazione mobile (che non concernono il progetto d'esame) simuleremo i sensori/attuatori abilitando tutti i componenti del team allo sviluppo e test del progetto.

\section{Requisiti}
\textcolor{red}{\textbf{Descrizione delle caratteristiche e funzionalità che il sistema prevede.}} % To remove!
Tenendo in considerazione le anticipazioni al capitolo \ref{sec:intro} il sistema si riduce a 3 principali componenti:
\begin{enumerate}
	\item \textbf{Dam Backend} (service):
	\begin{itemize}
		\item Salvataggio dati rilevati dai sensori.
		\item Esposizione interfaccia API accessibile tramite HTTP per lettura/salvataggio dati sensori.
	\end{itemize} 
	\item \textbf{Dam Frontend} (Dashboard):
	\begin{itemize}
		\item Grafico real-time relativo all'andamento del livello dell'acqua:
		\begin{itemize}
			\item Linea blu livello corrente acqua.
			\item Linea rossa d'allarme.
			\item Linea gialla d'allerta.
			\item Scelta periodo di aggiornamento grafico.
			\item Possibilità di forzare l'aggiornamento manualmente.
			\item Altri grafici mostranti dati su: temperatura dell'acqua, temperatura esterna, umidità, pressione atmosferica e pioggia.
		\end{itemize}
		\item Panoramic viewer della diga a 360°:
		\begin{itemize}
			\item Zoom in e out, possibilità di entrare in modalità full-scren.
			\item Visione colorata dei livelli di allerta sulla diga.
			\item Ultimo livello rilevato dell'acqua visualizzato sulla diga in tempo reale.
		\end{itemize}
		\item Homepage accessibile, con particolare riguardo a:
		\begin{itemize}
			\item Persona cieca.
			\item Persona ipovedente.
			\item Persona daltonica.
		\end{itemize}
	\end{itemize}
	\item \textbf{Dam Sensor} (Esp, arduino, mobile):
	\begin{itemize}
		\item Simulazione sensori e attuatori IOT:
		\begin{itemize}
			\item Sensore livello dell'acqua.
			\item Sensore del tempo atmosferico.
			\item Attuatore apertura diga.
		\end{itemize}
	\end{itemize}
\end{enumerate}

\section{Design}
\textcolor{red}{\textbf{Design dell'architettura del sistema e delle interfacce utente.}}
\textcolor{green}{\textbf{Personas e mockup con BALSAMIC........ :3}}

\section{Tecnologie}
\textcolor{red}{\textbf{Tecnologie adottate e motivazioni.}}
Di seguito l'elenco delle tecnologie adottate, come le abbiamo usate e perché sono state scelte.
\subsection{Node}
Node.js è un runtime JavaScript costruito sull'engine di Chrome's V8.
In quanto runtime Javascript asincrono event-driven, Node.js è progettato per costruire applicazioni network scalabili. Node.js è costituito da un event-loop a livello di runtime al contrario di altri sistemi che lo includono come libreria da chiamare con una chiamata bloccante. Il meccanismo ad event-loop potrebbe sembrare CPU intensive, ma in realtà se non c'è lavoro da svolgere Node.js va in sleep rilasciando la maggior parte delle risorse, ma rimanendo pronto a reagire agli eventi nel minor tempo possibile.
\\
\textcolor{green}{Perchè abbiamo usato Node?}

\subsection{Vue}
Vue è un framework in Javascript per costruire interfacce utente tramite l'uso di HTML, CSS e Javascript. Inoltre fornisce un modello di programmazione dichiarativo e basato sui componenti che aiuta a sviluppare efficientemente le interfacce utente, che siano semplici o complesse. Vue è progettato per essere flessibile e adottabile in modo incrementale, a seconda dei casi d'uso Vue può essere usato in diversi modi:
\begin{itemize}
	\item Potenziare HTML statico senza un passaggio di build.
	\item Incorporarsi come componente Web in qualsiasi pagina.
	\item Applicazioni Single-Page (SPA).
	\item Fullstack / Server-Side-Rendering (SSR).
	\item Jamstack / Static-Site-Generation (SSG).
	\item Può essere mirato allo sviluppo per Desktop, Mobile, WebGL o addirittura per terminale.
\end{itemize}
Nel nostro particolare caso tra Options API e Composition API abbiamo deciso di adottare il primo, Options API, come stile di programmazione, in quanto abbiamo pensato che rispecchiasse meglio l'idea che abbiamo di organizzazione del codice, bisogna inoltre sottolineare che i due stili sono del tutto equivalenti, infatti il primo è internamente costruito basandosi sul secondo, si tratta in tutto e per tutto del famoso "zucchero sintattico" che ci aiuta a mantenere alta la leggibilità del codice.\\
La scelta di usare Vue è stata quasi automatica, una volta aver esplorato la semplicità e le opportunità che mette a disposizione, abbiamo notato che per quello che volevamo realizzare molteplici aspetti del nostro progetto erano già coperti dal framework di Vue, questo ci apriva la strada ad un'implementazione ben organizzata e robusta diventando all'unisono la scelta perfetta per procedere.

\subsection{ApexChart}
ApexCharts è una moderna libreria di grafici che aiuta gli sviluppatori a creare visualizzazioni eleganti e interattive per pagine web. È un progetto open-source sotto la licenza MIT ed è di uso gratuito per applicazioni commerciali.\\
L'integrazione di grafici con ApexCharts è tanto semplice quanto può esserlo considerando la completezza dei documenti di riferimento (docs) e i 100+ esempi pronti ad essere usati.\\
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.7]{apexchart.png}
	\caption{Piccolo esempio di cosa è possibile fare tramite ApexCharts}
	\label{fig:apexchart}
\end{figure}
Tenendo in considerazione che ApexCharts offre la possibilità di integrarsi tramite Vue, viene automatico pensare che la scelta di questo framework sia ottima, infatti è di facile integrazione all'interno del codice senza sporcarlo con costrutti strani o particolari che andrebbero solamente a danneggiare la leggibilità dei nostri sorgenti, inoltre osservando l'immagine \ref{fig:apexchart} si nota qualche esempio di grafico ottenibile, in questo caso non possiamo apprezzare gli aggiornamenti in tempo reale, ma come si vedrà nel nostro sito, ApexCharts offre grafici in grado di aggiornarsi dinamicamente tramite animazioni fluide ed eleganti.\\
Avendo trovato comodo ed efficiente questo framework, lo abbiamo adottato per la principale visualizzazione di dati dei sensori del nostro progetto.

\subsection{Photo Sphere Viewer}
Photo-Sphere-Viewer è una libreria Javascript usabile per realizzare panorami a 360° tra cui:
\begin{itemize}
	\item \textbf{Spheres and cubemaps}: può visualizzare panorami standard equirettangolari e cubemaps.
	\item \textbf{Touchscreen, gyroscope and VR}: Interazioni semplici e orientate all'utente su tutti i tipi di dispositivo.
	\item \textbf{Markers system}: Visualizza testo, immagini e addirittura aree dinamiche direttamente sull'immagine renderizzata.
	\item \textbf{Fully configurable}: Diverse opzioni, metodi ed eventi consentono un'integrazione profonda nel sito in progettazione.
	\item \textbf{Plugins}: Nuovi plugin aggiungono nuove funzionalità senza sporcare la libreria principale.
	\item \textbf{Videos}: Supporto per i video.
\end{itemize}
La scelta di Photo Sphere Viewer viene naturale considerando i requisiti del nostro progetto, ogni punto di cui abbiamo bisogno è semplicemente implementabile tramite l'uso di una qualche funzionalità già presente all'interno di questa libreria, questo ci consente di concentrarci su aspetti più importanti del nostro sito piuttosto che perdere tempo a reinventare la ruota per realizzare piccole funzionalità.

\subsection{Axios}
\subsection{MongoDB}
\subsection{Docker}

\section{Codice}
\textcolor{red}{\textbf{Solo aspetti rilevanti.}}
\textcolor{green}{\textbf{Qui potremmo metterci la parte di codice che tira su l'immagine a 360 e il graph component.}}

\section{Test}
\textcolor{red}{\textbf{Test effettuati sul codice e test con utenti.}}
\textcolor{green}{\textbf{I test di accessibilità sulla homepage, SBAM!\\Simuliamo di averlo fatto provare a Mosè al posto che separare le acque.}}

\section{Deployment}
\textcolor{red}{\textbf{Rilascio, installazione e messa in funzione.}}
\textcolor{green}{\textbf{Docker, docker e ancora docker, mini tutorial su come mettere tutto in esecuzione, gioia di vivere.}}

\section{Conclusioni}
\textcolor{red}{\textbf{Conclusioni}}
\textcolor{green}{Le relazioni d'esempio sono lunghe un botto mi viene da piangere.}

\bibliographystyle{plain}
\bibliography{references}
\end{document}
